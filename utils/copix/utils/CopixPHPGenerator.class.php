<?php
/**
 * @package		copix
 * @subpackage	utils
 * @author		Gérald Croës
 * @link		http://www.copix.org
 * @license		http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public Licence, see LICENCE file
 */

/**
 * Classe qui contient un certain nombre de fonction pour faciliter la génération de PHP
 * 
 * @package		copix
 * @subpackage	utils
 */ 
class CopixPHPGenerator {
	/**
	 * Dernier contenu retourné par getPHPTags
	 *
	 * @var string
	 */
	private $_content = null;
	
	/**
	 * Constructeur
	 *
	 * @param array $pVars Tableau de variable (clef = nom, valeur = valeur)
	 */
	public function __construct ($pVars = null) {
		if (is_array ($pVars) && count ($pVars)) {
			$content = null;
			foreach ($pVars as $name => $value) {
				$content .= $this->getVariableDeclaration ($name, $value);
			}
			$this->getPHPTags ($content, true, 1);
		}
	}
	
	/**
	 * Retourne le dernier contenu généré via getPHPTags
	 *
	 * @return string
	 */
	public function getContent () {
		return $this->_content;
	}
	
	/**
	 * Ajoute les tags PHP en début et fin de chaine
	 * 
	 * @param string $pString Chaine PHP que l'on souhaite intégrer dans les balises PHP
	 * @param boolean $pAddGenerator Ajoute des commentaires sur le générateur
	 * @param int $pCallerLevel Niveau du caller
	 * @return string
	 */
	public function getPHPTags ($pString, $pAddGenerator = true, $pCallerLevel = 0, $pEndTag = true) {
		$toReturn = '<?php' . $this->getEndLine ();
		if ($pAddGenerator) {
			// on cherche les infos du générateur manuellement, sinon à l'appel de getGenerator, il y aura un niveau de getCaller "en plus"
			$generator = CopixDebug::getCaller ($pCallerLevel);
			$generatorFunction = CopixDebug::getCaller ($pCallerLevel + 1);
			$toReturn .= $this->getGenerator ($generator['file'], $generator['line'], $this->_getCallerFunction ($generatorFunction));
		}
		$toReturn .= $pString;
		if ($pEndTag) {
			$toReturn .= $this->getEndLine () . '?>';
		}
		
		return $this->_content = $toReturn;
	}
   
	/**
	 * Retourne le code PHP permettant de déclarer une variable avec une valeur
	 * 
	 * @param string $pVariableName Nom de la variable
	 * @param mixed $pValue Valeur de la variable
	 * @param int $pTabCount Nombre de tabulations
	 * @param int $pEndLineCount Nombre de retours à la ligne
	 * @return string
	 */
	public function getVariableDeclaration ($pVariableName, $pValue, $pTabCount = 0, $pEndLineCount = 1) {
		return $this->getLine ($pVariableName . ' = ' . var_export ($pValue, true) . ';', $pTabCount, $pEndLineCount);
	}
	
	/**
	 * Retourne le code PHP permettant de retourner le contenu d'une variable
	 *
	 * @param mixed $pValue Valeur de la variable
	 * @param int $pTabCount Nombre de tabulations
	 * @param int $pEndLineCount Nombre de retours à la ligne
	 * @return string
	 */
	public function getVariableReturn ($pValue, $pTabCount = 0, $pEndLineCount = 1) {
		return $this->getLine ('return ' . var_export ($pValue, true) . ';', $pTabCount, $pEndLineCount);
	}
	
	/**
	 * Retourne $pCount retours à la ligne
	 * 
	 * @param int $pCount Nombre de retours à la ligne
	 * @return string
	 */
	public function getEndLine ($pCount = 1) {
		return str_repeat ("\n", $pCount);
	}
	
	/**
	 * Retourne $pCount tabulations
	 *
	 * @param int $pCount Nombre de tabulations
	 * @return string
	 */
	public function getTabs ($pCount = 1) {
		return str_repeat ("\t", $pCount);
	}
	
	/**
	 * Retourne une ligne de code PHP, avec $pTabCount tabulations et $pEndLineCount retours à la ligne
	 *
	 * @param string $pLine Ligne de code PHP
	 * @param int $pTabCount Nombre de tabulations
	 * @param int $pEndLineCount Nombre de retours à la ligne
	 * @return string
	 */
	public function getLine ($pLine = null, $pTabCount = 0, $pEndLineCount = 1) {
		$toReturn = $this->getTabs ($pTabCount);
		$toReturn .= $pLine;
		$toReturn .= $this->getEndLine ($pEndLineCount);
		return $toReturn;
	}
	
	/**
	 * Renvoie un commentaire PHP avec des informations sur le .php qui l'a appelé
	 * 
	 * @param string $pFile Fichier appelant, si null sera le dernier appelant
	 * @param string $pLine Ligne appelante, si null sera la dernier appelante
	 * @param string $pFunction Fonction appelante (Object->method si c'est un objet), si null sera le dernier appelant
	 * @return string
	 */
	public function getGenerator ($pFile = null, $pLine = null, $pFunction = null) {
		$caller = CopixDebug::getCaller ();
		$callerFunction = CopixDebug::getCaller (1);
		$comments = array (
			'This file was generated by a PHP script on ' . date ('m/d/Y') . ' at ' . date ('H:i:s'),
			'',
			'File : ' . ((is_null ($pFile)) ? $caller['file'] : $pFile),
			'Line : ' . ((is_null ($pLine)) ? $caller['line'] : $pLine),
			'Function : ' . ((is_null ($pFunction)) ? $this->_getCallerFunction ($callerFunction) : $pFunction)
		);
		
		return $this->getPHPDoc ($comments, 0, 2);
	}
	
	/**
	 * Retourne un bloc de commentaire PHPDoc
	 *
	 * @param array $pDocs Commentaires, une ligne par commentaire. Peut être une chaine si on a un seul commentaire
	 * @param int $pTabCount Nombre de tabulations
	 * @param int $pNewLineCount Nombre de retours à la ligne
	 * @return string
	 */
	public function getPHPDoc ($pComments, $pTabCount = 0, $pNewLineCount = 1) {
		if (is_string ($pComments)) {
			$pComments = array ($pComments);
		}
		$toReturn = $this->getLine ('/**', $pTabCount);
		foreach ($pComments as $comment) {
			$toReturn .= $this->getLine (' * ' . $comment, $pTabCount);
		}
		$toReturn .= $this->getLine (' */', $pTabCount, $pNewLineCount);
		return $toReturn;
	}
	
	/**
	 * Retourne la function, obbjet->methode ou object::methode de l'appelant contenu dans $pCaller
	 *
	 * @param array $pCaller Appelant, retour de CopixDebug::getCaller ();
	 * @return string
	 */
	private function _getCallerFunction ($pCaller) {
		if (isset ($pCaller['class']) && $pCaller['class'] != '') {
			return $pCaller['class'] . $pCaller['type'] . $pCaller['function'];
		} else {
			return $pCaller['function'];
		}
	}
}