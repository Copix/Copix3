<?php
/**
 * @package		copix
 * @subpackage	test
 * @author		Nicolas Bastien
 * @copyright	CopixTeam
 * @link		http://copix.org
 * @license		http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public Licence, see LICENCE file
 */

/**
 * Générateur de classes de tests pour les modules
 * 
 * @package		copix
 * @subpackage	test
 */
class CopixTestClassGenerator {

	protected static $_strHeader = '<?php
/**
 * @package     %%package%%
 * @subpackage  %%subpackage%%
 */

/**
 * %%Description de la classe%% - generated by CopixTestClassGenerator
 *
 * @package     %%package%%
 * @subpackage  %%subpackage%%
 */
class %s extends CopixTest {
';

	protected static $_strFooter = '}';

	protected static $_strMethodTpl = '

	/**
	 * @todo Implement the testcase
	 */
	public function test%s () {
		// Remove the following lines when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
	}
';

	/**
	 * Génération de la classe de test pour le fichier données en paramètre
	 *
	 * @param string $pFromFileName le chemin du répertoire contenant la classe
	 * @param string $pOutputFileName le chemin du fichier de sortie, par défaut le répertoire des tests du module
	 * @return int le nombre de fichiers générés
	 */
	public static function generateTestClass ($pFromFileName, $outputFolder = '') {

		if (!is_readable($pFromFileName)) {
			throw new CopixException("Le fichier $pFromFileName n'est pas lisible.");
		}
		
		$filePath = CopixFile::extractFilePath($pFromFileName);
		if( $outputFolder == '' ){
			$outputFolder = $filePath . '..' . DIRECTORY_SEPARATOR . COPIX_TESTS_DIR;
		}

		$nbFileGenerated = 0;
		foreach (self::getClasses($pFromFileName) as $className) {
			//On n'écrase pas les fichiers existants
			$filepath = $outputFolder . $className . 'test.class.php';
			if (!file_exists($filepath)) {
				self::_writeTestClassFile($className, $filepath);
				$nbFileGenerated++;
			}
		}
		return $nbFileGenerated;
	}

	/**
	 * Génération des classes de tests pour un module complet (toute les fichiers du sous-répertoire classes du module)
	 *
	 * @param string $pModuleName nom du module
	 * @return int $nbFileGenerated le nombre de fichiers générés
	 */
	public static function generateTestClassForModule ($pModuleName) {
		$modulePath = CopixModule::getPath($pModuleName);
		if (is_null($modulePath)) {
			throw new CopixException("Module invalide : " . $pModuleName);
		}
		//Création du répertoire pour les classes de tests
		CopixFile::createDir($modulePath . COPIX_TESTS_DIR);

		// Récupération des chemins vers les fichiers de classe (y compris dans les dossiers)
		$classesDir = CopixModule::getPath('boutique').COPIX_CLASSES_DIR;
		$files = CopixFile::search( '*.php', $classesDir, true );
		
		$nbFileGenerated = 0;
		foreach ($files as $filepath) {
			$nbFileGenerated += self::generateTestClass($filepath, $modulePath . COPIX_TESTS_DIR);
		}
		return $nbFileGenerated;
	}

	/**
	 * Récupère les noms des classes définies dans le fichier passé en paramètre
	 *
	 * @param string $pFileName le nom du fichier
	 * @return array
	 */
	public static function getClasses($pFileName) {
		$classPrefix = null;
		//Cas spécial des DAO et DAORecord
		//Les DAO et DAORecord étendent un fichier compilé or lors d'un appel à require_once
		//le process ne passe pas via la factory qui génère la dao compilé et
		//on obtient donc une Fatal error
		if (strpos($pFileName, '.dao.php') !== false) {	   $classPrefix = 'DAO'; }
		if (strpos($pFileName, '.record.php') !== false) { $classPrefix = 'DAORecord'; }
		if (!is_null ($classPrefix)) {
			$fileName = CopixFile::extractFileName($pFileName);
			$className = $classPrefix . substr($fileName, 0, strpos($fileName, '.'));
			return array($className);
		}

		//Cas normal
		$arClassesBefore = get_declared_classes();
		require_once $pFileName;
		return array_diff(get_declared_classes(), $arClassesBefore);
	}
	
	/**
	 * Création du fichier de test
	 *
	 * @param string $className le nom de la classe à tester
	 * @param string $outputFileName le fichier à générer
	 * @return	bool si la fonction a correctement écrit les données dans le fichier
	 */
	private static function _writeTestClassFile($className, $outputFileName) {
		$class = new ReflectionClass($className);

		if ($class->isAbstract()) {
			//On ne teste pas une classe abstraite
			return false;
		}

		$strFile = sprintf(self::$_strHeader, $className . 'Test');

		foreach ($class->getMethods() as $method) {
            if (!$method->isConstructor() &&
                !$method->isAbstract() &&
                 $method->isPublic() &&
				 //On vérifie que l'on test les méthodes de la classe et pas une hérité
				 (strtolower($method->getDeclaringClass()->getName()) == strtolower($className))) {

				$strFile .= sprintf(self::$_strMethodTpl, $method->getName());
			}
		}

		$strFile .= self::$_strFooter;
		return CopixFile::write(strtolower($outputFileName), $strFile);
	}

}